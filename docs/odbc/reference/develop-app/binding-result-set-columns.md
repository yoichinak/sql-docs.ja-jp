---
description: 結果セットの列のバインド
title: 結果セットの列をバインドする |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- result sets [ODBC], binding columns
- binding columns [ODBC]
ms.assetid: 4bc9c30f-83ae-4766-a746-032953c187ad
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e6a228de81deb5cdfdaa62ee7940185b14bcaef8
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/17/2020
ms.locfileid: "88499945"
---
# <a name="binding-result-set-columns"></a>結果セットの列のバインド
アプリケーションでは、列をまったくバインドしないなど、選択したとおりに結果セットの列をいくつでもバインドできます。 データ行がフェッチされると、ドライバーはバインドされた列のデータをアプリケーションに返します。 アプリケーションが結果セット内のすべての列をバインドするかどうかは、アプリケーションによって異なります。 たとえば、レポートを生成するアプリケーションは通常、固定された形式です。このようなアプリケーションは、レポートで使用されているすべての列を含む結果セットを作成し、これらのすべての列のデータをバインドして取得します。 データがいっぱいになっている画面を表示するアプリケーションでは、表示する列をユーザーが決定できることがあります。このようなアプリケーションは、ユーザーが必要とする可能性のあるすべての列を含む結果セットを作成しますが、ユーザーが選択した列に対してのみデータをバインドおよび取得します。  
  
 **SQLGetData**を呼び出すことによって、バインドされていない列からデータを取得できます。 これは、多くの場合、1つのバッファーの長さを超え、部分的に取得する必要がある長いデータを取得するために呼び出されます。  
  
 行がフェッチされた後でも、いつでも列をバインドできます。 ただし、新しいバインドは、次に行がフェッチされるまで有効になりません。これらは、既にフェッチされた行のデータには適用されません。  
  
 変数は、異なる変数が列にバインドされるまで、列にバインドされたままになります。この場合、 **SQLBindCol** オプションを指定して SQL_UNBIND **SQLFreeStmt** を呼び出すことによってすべての列がバインド解除されるか、ステートメントが解放されるまで、すべての列がバインド解除されるまで、列にバインドされます。 このため、アプリケーションは、バインドされているすべての変数が有効なままであることを確認する必要があります。 詳細については、「 [バッファーの割り当てと解放](../../../odbc/reference/develop-app/allocating-and-freeing-buffers.md)」を参照してください。  
  
 列のバインドは、ステートメント構造に関連付けられている情報であるため、任意の順序で設定できます。 また、結果セットにも依存しません。 たとえば、次の SQL ステートメントによって生成される結果セットの列をアプリケーションがバインドするとします。  
  
```  
SELECT * FROM Orders  
```  
  
 アプリケーションで SQL ステートメントを実行する場合  
  
```  
SELECT * FROM Lines  
```  
  
 同じステートメントハンドルでは、最初の結果セットの列バインドは、ステートメント構造に格納されているバインドであるため、有効なままです。 ほとんどの場合、これは不適切なプログラミング手法であり、回避する必要があります。 代わりに、アプリケーションは、SQL_UNBIND オプションを指定して **SQLFreeStmt** を呼び出して、すべての古い列のバインドを解除してから、新しい列をバインドする必要があります。
