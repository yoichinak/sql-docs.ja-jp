---
description: データの行のフェッチ
title: データ行のフェッチ |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetch function [ODBC], fetching a row of data
- cursors [ODBC], fetching rows
- result sets [ODBC], fetching
- fetches [ODBC], row of data
ms.assetid: 16d4a380-0d83-456b-aeee-f10738944e86
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 71ced7d7df30f1bb4f784317b76f7b42553951df
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/17/2020
ms.locfileid: "88499892"
---
# <a name="fetching-a-row-of-data"></a>データの行のフェッチ
データ行をフェッチするために、アプリケーションは **Sqlfetch**を呼び出します。 **Sqlfetch** は任意の種類のカーソルを使用して呼び出すことができますが、前方参照専用の方向でのみ行セットカーソルを移動します。 **Sqlfetch** はカーソルを次の行に進め、 **SQLBindCol**の呼び出しでバインドされたすべての列のデータを返します。 カーソルが結果セットの末尾に達すると、 **Sqlfetch** は SQL_NO_DATA を返します。 **Sqlfetch**の呼び出しの例については、「 [Using SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)」を参照してください。  
  
 **Sqlfetch**の実装方法はドライバーによって異なりますが、一般的なパターンは、ドライバーがデータソースからバインドされた列のデータを取得し、バインドされた変数の型に従って変換し、変換されたデータをそれらの変数に配置することです。 ドライバーがデータを変換できない場合、 **Sqlfetch** はエラーを返します。 アプリケーションは行のフェッチを続行できますが、現在の行のデータは失われます。 バインドされていない列のデータは、ドライバーによって異なりますが、ほとんどのドライバーは、ドライバーを取得または破棄するか、まったく取得しません。  
  
 また、ドライバーは、バインドされているすべての長さ/インジケーターバッファーの値も設定します。 列のデータ値が NULL の場合、ドライバーは対応する長さ/インジケーターバッファーを SQL_NULL_DATA に設定します。 データ値が NULL でない場合、ドライバーは変換後のデータのバイト長に長さ/インジケーターバッファーを設定します。 この長さを特定できない場合は、複数の関数呼び出しによって取得される長いデータの場合と同様に、ドライバーは長さ/インジケーターバッファーを SQL_NO_TOTAL に設定します。 整数や日付構造体などの固定長データ型の場合、バイト長はデータ型のサイズになります。  
  
 文字データやバイナリデータなどの可変長データの場合、ドライバーは、変換されたデータのバイト長を、列にバインドされているバッファーのバイト長と照合します。バッファーの長さは、 **SQLBindCol**の*bufferlength*引数で指定されます。 変換されたデータのバイト長がバッファーのバイト長を超える場合、ドライバーはバッファーに格納されるデータを切り捨て、長さ/インジケーターバッファー内で切り捨てられていない長さを返し、SQL_SUCCESS_WITH_INFO を返し、SQLSTATE 01004 (データが切り捨てられた) を診断に配置します。 唯一の例外は、 **Sqlfetch**によって返されたときに可変長のブックマークが切り捨てられ、SQLSTATE 22001 (文字列データ、右の切り捨て) が返される場合です。  
  
 固定長のデータは切り捨てられません。これは、ドライバーが、バインドされたバッファーのサイズがデータ型のサイズであると想定しているためです。 通常、アプリケーションはデータ値全体を保持するのに十分な大きさのバッファーをバインドするので、データの切り捨てはめったに発生しません。メタデータから必要なサイズを決定します。 ただし、アプリケーションは、小さすぎると認識されるバッファーを明示的にバインドする場合があります。 たとえば、部分の説明の最初の20文字または長いテキストの列の最初の100文字を取得して表示する場合があります。  
  
 文字データは、切り捨てられた場合でも、アプリケーションに返される前に、ドライバーによって null で終了される必要があります。 Null 終了文字は、返されたバイト長には含まれませんが、バインドされたバッファーには領域が必要です。 たとえば、ASCII 文字セットの文字データで構成される文字列を使用するアプリケーションでは、ドライバーでは50文字のデータが返され、アプリケーションのバッファーは25バイトの長さであるとします。 アプリケーションのバッファーでは、ドライバーは最初の24文字の後に null 終端文字を返します。 長さ/インジケーターバッファーでは、バイト長は50を返します。  
  
 アプリケーションでは、結果セットを作成するステートメントを実行する前に SQL_ATTR_MAX_ROWS ステートメント属性を設定することによって、結果セット内の行の数を制限できます。 たとえば、レポートの書式設定に使用されるアプリケーションのプレビューモードでは、レポートの最初のページを表示するために必要なデータは1つだけです。 結果セットのサイズを制限することで、このような機能がより高速に実行されるようになります。 このステートメント属性はネットワークトラフィックを削減するためのものであり、すべてのドライバーでサポートされていない可能性があります。
