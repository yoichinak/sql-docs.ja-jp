---
description: Alignment
title: Alignment |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 1402eee289111ca100e80730d8df4a6d0e3299cd
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/17/2020
ms.locfileid: "88483145"
---
# <a name="alignment"></a>Alignment
ODBC アプリケーションのアラインメントの問題は、通常、他のアプリケーションとは異なります。 つまり、ほとんどの ODBC アプリケーションは、アラインメントに関してほとんどまたはまったく問題がありません。 アドレスを整列しない場合のペナルティは、ハードウェアとオペレーティングシステムによって異なります。また、パフォーマンスがわずかに低下するか、致命的な実行時エラーとして重要な場合があります。 そのため、ODBC アプリケーションや、特にポータブル ODBC アプリケーションは、データを適切に配置するために注意する必要があります。  
  
 ODBC アプリケーションでアラインメントの問題が発生した場合の例として、大きなメモリブロックを割り当てて、そのメモリの異なる部分を結果セットの列にバインドする場合があります。 これは、汎用アプリケーションが実行時に結果セットの構造を決定し、それに応じてメモリを割り当ててバインドする必要がある場合に発生する可能性が最も高くなります。  
  
 たとえば、アプリケーションがユーザーによって入力された **SELECT** ステートメントを実行し、このステートメントから結果をフェッチするとします。 この結果セットの構造は、プログラムの作成時には認識されないため、アプリケーションは、結果セットの作成後に各列の種類を決定し、それに応じてメモリをバインドする必要があります。 これを行う最も簡単な方法は、大きなメモリブロックを割り当てて、そのブロック内の異なるアドレスを各列にバインドすることです。 列のデータにアクセスするために、アプリケーションはその列にバインドされているメモリをキャストします。  
  
 次の図は、各 SQL データ型の既定の C データ型を使用して、サンプルの結果セットと、メモリブロックをバインドする方法を示しています。 各 "X" は、1バイトのメモリを表します。 (この例では、列にバインドされているデータバッファーのみを示しています。 これはわかりやすくするために行われます。 実際のコードでは、長さ/インジケーターバッファーも揃える必要があります)。  
  
 ![既定の C データ型から SQL データ型へのバインド](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 バインドされたアドレスが *アドレス* 配列に格納されている場合、アプリケーションは次の式を使用して、各列にバインドされているメモリにアクセスします。  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 2番目と3番目の列にバインドされたアドレスは奇数バイトで開始し、3番目の列にバインドされたアドレスは、SDWORD のサイズである4で割り切れないことに注意してください。 コンピューターによっては、これが問題になることはありません。それ以外の場合、パフォーマンスがわずかに低下します。それ以外の場合は、致命的な実行時エラーが発生します。 より適切な解決策として、各バインドされたアドレスを自然な配置境界に配置します。 UCHAR の場合は1、ソードの場合は2、SDWORD では4の場合は、次の図に示すようになります。 "X" は使用されているメモリのバイトを表し、"O" は未使用のメモリのバイトを表します。  
  
 ![自然な配置境界によるバインド](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 このソリューションでは、アプリケーションのすべてのメモリが使用されるわけではありませんが、アラインメントに関する問題は発生しません。 残念ながら、このソリューションを実装するには、その型に応じて各列を個別に配置する必要があるため、多くのコードが必要になります。 より簡単なソリューションは、次の図に示す例では、すべての列を最大のアラインメント境界のサイズに揃えることです。  
  
 ![最大の配置境界によるバインド](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 このソリューションには大きな穴が残されていますが、実装するコードは比較的単純で高速です。 ほとんどの場合、これにより、使用されていないメモリで支払われたペナルティが相殺されます。 このメソッドの使用例については、「 [Using SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)」を参照してください。
