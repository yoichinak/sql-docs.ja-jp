---
description: レコードセットの操作
title: レコードセットの操作 |Microsoft Docs
ms.prod: sql
ms.prod_service: connectivity
ms.technology: ado
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- Recordset object [ADO]
ms.assetid: bdf9a56a-de4a-44de-9111-2f11ab7b16ea
author: rothja
ms.author: jroth
ms.openlocfilehash: 0a8ffeab33125b3b13ca5725125654bd3ed1f822
ms.sourcegitcommit: 18a98ea6a30d448aa6195e10ea2413be7e837e94
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/27/2020
ms.locfileid: "88978843"
---
# <a name="working-with-recordsets"></a>レコードセットの操作
**レコードセット**オブジェクトには、結果セット内のデータの順序を変更したり、指定した条件に基づいて特定のレコードを検索したり、インデックスを使用して検索操作を最適化したりするための機能が組み込まれています。 これらの機能を使用できるかどうかは、プロバイダーおよび場合によっては、 [インデックス](../../../ado/reference/ado-api/index-property.md) プロパティの構造 (データソース自体の構造) によって異なります。  
  
## <a name="arranging-data"></a>データの配置  
 多くの場合、 **レコードセット** 内のデータを並べ替えるには、結果を返すために使用する SQL コマンドで order by 句を指定する方法が最も効率的です。 ただし、既に作成されている **レコードセット** 内のデータの順序を変更することが必要になる場合があります。 **Sort**プロパティを使用して、**レコードセット**の行を走査する順序を設定できます。 さらに、 **フィルター** プロパティは、行を走査するときにアクセスできる行を決定します。  
  
 **Sort**プロパティは、並べ替えの対象となる**レコードセット**内のフィールド名を示す**文字列**値を設定または返します。 各名前はコンマで区切られ、必要に応じてスペースとキーワード **ASC** (フィールドを昇順に並べ替える) または **DESC** (フィールドを降順で並べ替える) を指定します。 既定では、キーワードが指定されていない場合、フィールドは昇順に並べ替えられます。  
  
 データは物理的には再配置されず、インデックスによって指定された順序でアクセスされるため、並べ替え操作は効率的です。  
  
 **Sort**プロパティでは、[カーソル位置](../../../ado/reference/ado-api/cursorlocation-property-ado.md)プロパティを**adUseClient**に設定する必要があります。 インデックスがまだ存在しない場合は、 **Sort** プロパティで指定された各フィールドに対して一時インデックスが作成されます。  
  
 **Sort**プロパティを空の文字列に設定すると、行が元の順序にリセットされ、一時インデックスが削除されます。 既存のインデックスは削除されません。  
  
 **レコードセット**に*firstName*、 *middleInitial*、 *lastName*という3つのフィールドが含まれているとします。 **Sort**プロパティを文字列 "" に設定します `lastName DESC, firstName ASC` 。これにより、**レコードセット**が姓で降順に並べ替えられ、名が昇順に並べ替えられます。 ミドルネームのイニシャルは無視されます。  
  
 並べ替え条件文字列で参照されているフィールドの名前は、 **asc** および **desc**と競合するため、"asc" または "desc" という名前にすることはできません。 **レコードセット**を返すクエリで**AS**キーワードを使用して、名前が競合するフィールドに別名を指定します。  
  
 **レコードセット**のフィルター処理の詳細については、このトピックで後述する「結果のフィルター処理」を参照してください。  
  
## <a name="finding-a-specific-record"></a>特定のレコードの検索  
 ADO では、**レコードセット**内の特定のレコードを検索するための[Find](../../../ado/reference/ado-api/find-method-ado.md)メソッドと[Seek](../../../ado/reference/ado-api/seek-method.md)メソッドが用意されています。 **Find**メソッドは、さまざまなプロバイダーでサポートされていますが、1つの検索条件に限定されています。 **Seek**メソッドは複数の条件の検索をサポートしていますが、多くのプロバイダーではサポートされていません。  
  
 フィールドのインデックスを使用すると、**レコードセット**オブジェクトの**Find**メソッドおよび**Sort**および**Filter**プロパティのパフォーマンスを大幅に向上させることができます。 Dynamic [Optimize](../../../ado/reference/ado-api/optimize-property-dynamic-ado.md)プロパティを設定することにより、 **Field**オブジェクトの内部インデックスを作成できます。 この動的プロパティは、[[カーソルの場所](../../../ado/reference/ado-api/cursorlocation-property-ado.md)] プロパティを**adUseClient**に設定すると、 **Field**オブジェクトの**Properties**コレクションに追加されます。 このインデックスは ADO の内部にあることに注意してください。このインデックスにアクセスしたり、他の目的で使用したりすることはできません。 また、このインデックスは、**レコードセット**オブジェクトの[index](../../../ado/reference/ado-api/index-property.md)プロパティとは異なります。  
  
 **Find**メソッドでは、**レコードセット**の列 (フィールド) 内の値がすばやく検索されます。 列の **Find** メソッドの速度を向上させるには、 **Optimize** プロパティを使用して列にインデックスを作成します。  
  
 **Find**メソッドを使用すると、検索対象が1つのフィールドの内容に限定されます。 **Seek**メソッドでは、インデックスがあり、他にも制限があることが必要です。 インデックスのベースになっていない複数のフィールドを検索する必要がある場合、またはプロバイダーがインデックスをサポートしていない場合は、**レコードセット**オブジェクトの**Filter**プロパティを使用して結果を制限できます。  
  
### <a name="find"></a>Find  
 **Find**メソッドは、指定された条件を満たす行の**レコードセット**を検索します。 必要に応じて、開始行からの検索、開始行、およびオフセットの方向を指定することもできます。 条件が満たされている場合は、見つかったレコードに現在の行の位置が設定されます。それ以外の場合は、検索の方向に応じて、 **レコードセット**の最後 (または先頭) に位置が設定されます。  
  
 条件には、単一列の名前のみを指定できます。 言い換えると、このメソッドは複数列の検索をサポートしていません。  
  
 条件の比較演算子には、" **>** " (より大きい)、"* * \<**" (less than), "=" (equal), "> =" (以上)、"<=" (以下)、"<>" (不等号)、"LIKE" (パターンマッチング) のいずれかを指定できます。  
  
 条件値には、文字列、浮動小数点数、または日付を指定できます。 文字列値は、単一引用符または "#" (シャープ記号) マーク (たとえば、"state = ' WA '" または "state = #WA #") で区切られます。 日付の値は、"#" (シャープ記号) マークで区切られます (たとえば、"start_date > #7/22/97 #")。  
  
 比較演算子が "like" の場合、文字列値にアスタリスク (*) を含めることで、任意の文字または部分文字列の1回以上の出現箇所を検索できます。 たとえば、"m のような状態 \* " は Maine とマサチューセッツに一致します。 また、先頭と末尾のアスタリスクを使用して、値に含まれている部分文字列を検索することもできます。 たとえば、"州 like ' \* as \* '" はアラスカ、アーカンソー、およびマサチューセッツに一致します。  
  
 前に示したように、アスタリスクは、条件文字列の末尾、または条件文字列の先頭と末尾の両方で使用できます。 先頭のワイルドカード (' * str ') または埋め込みワイルドカード (r) としてアスタリスクを使用することはできません \* 。 これにより、エラーが発生します。  
  
### <a name="seek-and-index"></a>シークとインデックス  
 基になるプロバイダーが**レコードセット**オブジェクトのインデックスをサポートしている場合は、 **Index**プロパティと共に**Seek**メソッドを使用します。 [サポート](../../../ado/reference/ado-api/supports-method.md)**(adseek)** メソッドを使用して、基になるプロバイダーが**Seek**をサポートするかどうかを判断し、**サポート (adseek)** メソッドを使用して、プロバイダーがインデックスをサポートしているかどうかを判断します。 (たとえば、 [Microsoft Jet の OLE DB プロバイダー](../../../ado/guide/appendixes/microsoft-ole-db-provider-for-microsoft-jet.md) では、 **Seek** および **Index**がサポートされています)。  
  
 **Seek**が目的の行を見つけられない場合、エラーは発生せず、行は**レコードセット**の末尾に配置されます。 このメソッドを実行する前に、 **index** プロパティを目的のインデックスに設定します。  
  
 このメソッドは、サーバー側のカーソルでのみサポートされています。 **レコードセット**オブジェクトの[カーソル位置](../../../ado/reference/ado-api/cursorlocation-property-ado.md)プロパティ値が**adUseClient**の場合、シークはサポートされません。  
  
 このメソッドは、 **レコードセット** オブジェクトが [commandtypeenum](../../../ado/reference/ado-api/commandtypeenum.md) 値 **adcmdtabledirect**で開かれている場合にのみ使用できます。  
  
## <a name="filtering-the-results"></a>結果のフィルター処理  
 **Find**メソッドを使用すると、検索対象が1つのフィールドの内容に限定されます。 **Seek**メソッドでは、インデックスがあり、他にも制限があることが必要です。 インデックスのベースではない複数のフィールドを検索する必要がある場合、またはプロバイダーがインデックスをサポートしていない場合は、**レコードセット**オブジェクトの**Filter**プロパティを使用して結果を制限できます。  
  
 **フィルター**プロパティを使用して、レコード**セット**オブジェクトのレコードを選択的に表示します。 フィルター選択された**レコードセット**が現在のカーソルになります。つまり、**フィルター条件を**満たしていないレコードは、**フィルター**が削除されるまで**レコードセット**で使用できません。 現在のカーソルに基づいて値を返すその他のプロパティは、 **AbsolutePosition**、 **AbsolutePage**、 **RecordCount**、 **PageCount**など、影響を受けます。 これは、 **Filter** プロパティを特定の値に設定すると、現在のレコードが新しい値を満たす最初のレコードに移動するためです。  
  
 **Filter**プロパティは variant 引数を受け取ります。 この値は、 **フィルター** プロパティを使用するための3つのメソッド (条件文字列、 **filtergroupenum** 定数、またはブックマークの配列) のいずれかを表します。 詳細については、このトピックで後述する「条件文字列を使用したフィルター処理、定数を使用したフィルター処理、およびブックマークを使用したフィルター処理」を参照してください。  
  
> [!NOTE]
>  選択するデータがわかっている場合は、**フィルター**プロパティに依存するのではなく、結果セットを効果的にフィルター処理する SQL ステートメントを使用して**レコードセット**を開く方が効率的です。  
  
 **レコードセット**からフィルターを削除するには、 **adfilternone**定数を使用します。 **Filter**プロパティを長さ0の文字列 ("") に設定すると、 **adfilternone**定数を使用する場合と同じ効果があります。  
  
### <a name="filtering-with-a-criteria-string"></a>条件文字列を使用したフィルター処理  
 条件文字列は、 *フィールド名演算子の値* (など) の句で構成され `"LastName = 'Smith'"` ます。 複合句を作成するには、個別の句を **and** (たとえば、 `"LastName = 'Smith' AND FirstName = 'John'"` ) や **or** (など) と連結し `"LastName = 'Smith' OR LastName = 'Jones'"` ます。 条件文字列には、次のガイドラインを使用します。  
  
-   *FieldName* は、 **レコードセット**の有効なフィールド名である必要があります。 フィールド名にスペースが含まれている場合は、名前を角かっこで囲む必要があります。  
  
-   *演算子*は、、、 **\<**, **>** **\<=**, **>=** **<>** 、 **=** 、または**LIKE**のいずれかである必要があります。  
  
-   *値* は、フィールドの値を比較するときに使用する値です (たとえば、、、 `'Smith'` `#8/24/95#` `12.345` 、または `$50.00` )。 文字列には単一引用符 (') を使用し、日付にはシャープ記号 () を使用し `#` ます。 数値の場合は、小数点、ドル記号、および指数表記を使用できます。 *Operator*が**LIKE**の場合、*値*にはワイルドカード文字を使用できます。 アスタリスク ( \* ) とパーセント記号 (%) のみワイルドカード文字を使用できます。また、文字列の最後の文字である必要があります。 *値* を null にすることはできません。  
  
    > [!NOTE]
    >  フィルター *値*に単一引用符 (') を含めるには、2つの単一引用符を使用して1つのを表します。 たとえば、 *O'Malley*に対してフィルター処理を行うには、条件文字列をにする必要があり `"col1 = 'O''Malley'"` ます。 フィルター値の先頭と末尾の両方に単一引用符を含めるには、文字列をシャープ記号 (#) で囲みます。 たとえば、 *' 1 '* でフィルター処理するには、条件文字列をにする必要があり `"col1 = #'1'#"` ます。  
  
 **And**と**OR**の間には優先順位がありません。 句は、かっこ内でグループ化できます。 ただし、 **or** で結合された句をグループ化することはできません。その後、次のようにとを使用して、グループを別の句に結合することはできません。  
  
```  
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John'  
```  
  
 代わりに、次のようにこのフィルターを構築します。  
  
```  
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John')  
```  
  
 **LIKE**句では、パターンの先頭と末尾にワイルドカードを使用できます (たとえば、 `LastName Like '*mit*'` )。または、パターンの最後 (たとえば、) でのみ使用でき `LastName Like 'Smit*'` ます。  
  
### <a name="filtering-with-a-constant"></a>定数を使用したフィルター処理  
 **レコードセット**をフィルター処理するには、次の定数を使用できます。  
  
|定数|説明|  
|--------------|-----------------|  
|**adFilterAffectedRecords**|最後の **Delete**、 **Resync**、 **UpdateBatch**、または **CancelBatch** 呼び出しの影響を受けたレコードのみを表示するためのフィルター。|  
|**Adfilter衝突レコード**|前回のバッチ更新に失敗したレコードを表示するためのフィルター。|  
|**adFilterFetchedRecords**|現在のキャッシュ内のレコードを表示するためのフィルター。つまり、データベースからレコードを取得するための最後の呼び出しの結果です。|  
|**adFilterNone**|現在のフィルターを削除し、表示するすべてのレコードを復元します。|  
|**adFilterPendingRecords**|サーバーにまだ送信されていない、変更されたレコードのみを表示するためのフィルター。 バッチ更新モードにのみ適用されます。|  
  
 フィルター定数を使用すると、次の例に示すように、最後の **UpdateBatch** メソッド呼び出し中に影響を受けたレコードのみを表示できるようになり、バッチ更新モード中の個々のレコードの競合を簡単に解決できます。  
  
 `Attribute VB_Name = "modExaminingData"`  
  
### <a name="filtering-with-bookmarks"></a>ブックマークを使用したフィルター処理  
 最後に、ブックマークのバリアント配列を **フィルター** プロパティに渡すことができます。 結果として得られるカーソルには、ブックマークがプロパティに渡されたレコードだけが格納されます。 次のコード例では、 *ProductName*フィールドに "B" を含むレコード**セット**内のレコードからブックマークの配列を作成します。 次に、配列を **フィルター** プロパティに渡し、結果として得られるフィルター処理された **レコードセット**に関する情報を表示します。  
  
```  
'BeginFilterBkmk  
Dim vBkmkArray() As Variant  
Dim i As Integer  
  
'Recordset created using "SELECT * FROM Products" as command.  
'So, we will check to see if ProductName has a capital B, and  
'if so, add to the array.  
i = 0  
Do While Not objRs.EOF  
    If InStr(1, objRs("ProductName"), "B") Then  
        ReDim Preserve vBkmkArray(i)  
        vBkmkArray(i) = objRs.Bookmark  
        i = i + 1  
        Debug.Print objRs("ProductName")  
    End If  
    objRs.MoveNext  
Loop  
  
'Filter using the array of bookmarks.  
objRs.Filter = vBkmkArray  
  
objRs.MoveFirst  
Do While Not objRs.EOF  
    Debug.Print objRs("ProductName")  
    objRs.MoveNext  
Loop  
'EndFilterBkmk  
```  
  
## <a name="creating-a-clone-of-a-recordset"></a>レコードセットの複製の作成  
 複数の重複したレコード**セット**オブジェクトを作成するには、 **Clone**メソッドを使用します。特に、特定のレコードのセットに複数の現在のレコードを保持する場合に使用します。 **複製**方法を使用する方が、元の**レコードセット**と同じ定義で新しい Recordset オブジェクトを作成して開くよりも効率的です。  
  
 新しく作成された複製の現在のレコードは、もともと最初のレコードに設定されます。 複製された **レコードセット** 内の現在のレコードポインターは、元のレコードと同期されません。 各 **レコードセット**で個別に移動できます。  
  
 1つの **レコードセット** オブジェクトに対して行った変更は、カーソルの種類に関係なく、すべての複製に表示されます。 ただし、元の**レコードセット**に対して再[クエリ](../../../ado/reference/ado-api/requery-method.md)を実行すると、複製は元のレコードと同期されなくなります。  
  
 元の **レコードセット** を閉じると、コピーが閉じられることはなく、コピーを終了しても、元のコピーまたは他のコピーを閉じることはできません。  
  
 **レコードセット**オブジェクトを複製できるのは、ブックマークがサポートされている場合のみです。 ブックマーク値は交換可能です。つまり、1つの **レコードセット** オブジェクトからのブックマーク参照は、その複製内の同じレコードを参照します。
