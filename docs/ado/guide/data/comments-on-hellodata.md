---
description: HelloData に関するコメント
title: HelloData | に関するコメントMicrosoft Docs
ms.prod: sql
ms.prod_service: connectivity
ms.technology: ado
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- hellodata sample application [ADO]
ms.assetid: a2831d77-7040-4b73-bbae-fe0bf78107ed
author: rothja
ms.author: jroth
ms.openlocfilehash: 139c788c81a5055d5d567625d314ad14c657e3e7
ms.sourcegitcommit: 18a98ea6a30d448aa6195e10ea2413be7e837e94
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/27/2020
ms.locfileid: "88991533"
---
# <a name="comments-on-hellodata"></a>HelloData に関するコメント
HelloData アプリケーションでは、一般的な ADO アプリケーションの基本的な操作 (データの取得、調査、編集、更新) を実行します。 アプリケーションを起動するときに、最初のボタン [ **データの取得**] をクリックします。 これにより、 **GetData** サブルーチンが実行されます。  
  
## <a name="getdata"></a>GetData  
 **GetData** によって、有効な接続文字列がモジュールレベルの変数 *m_sConnStr*に配置されます。 接続文字列の詳細については、「 [接続文字列の作成](./creating-a-connection-string.md)」を参照してください。  
  
 Visual Basic **OnError** ステートメントを使用してエラーハンドラーを割り当てます。 ADO でのエラー処理の詳細については、「 [エラー処理](./error-handling.md)」を参照してください。 新しい **接続** オブジェクトが作成され、 **カーソル位置** プロパティが **adUseClient** に設定されます。これは、HelloData の例では、切断された *レコードセット*が作成されるためです。 これは、データがデータソースからフェッチされるとすぐに、データソースとの物理的な接続が切断されることを意味しますが、 **レコードセット** オブジェクトにローカルにキャッシュされているデータを操作できます。  
  
 接続が開かれたら、SQL 文字列を変数 (sSQL) に割り当てます。 次に、新しい **レコードセット** オブジェクトのインスタンスを作成し `m_oRecordset1` ます。 次のコード行で、既存の**接続**を介して**レコードセット**を開き、 `sSQL` **レコードセット**のソースとしてを渡します。 ADO は、 **レコードセット** のソースとして渡された SQL 文字列が、最後の引数に **Adcmdtext** を **レコードセットの Open** メソッドに渡すことによって、コマンドのテキスト定義であることを判断するのに役立ちます。 また、この行では、**レコードセット**に関連付けられている**LockType**と**CursorType**も設定します。  
  
 次のコード行では、 **Marshaloptions** プロパティを **adMarshalModifiedOnly**に設定しています。 **Marshaloptions** は、中間層 (または Web サーバー) にマーシャリングするレコードを示します。 マーシャリングの詳細については、COM のドキュメントを参照してください。 **AdMarshalModifiedOnly**をクライアント側のカーソル ([cursor location](../../reference/ado-api/cursorlocation-property-ado.md)adUseClient) と共に使用すると  =  **adUseClient**、クライアントで変更されたレコードだけが中間層に書き戻されます。 **Marshaloptions**を**adMarshalModifiedOnly**に設定すると、マーシャリングされる行が減るため、パフォーマンスが向上します。  
  
 次に、[ **ActiveConnection** ] プロパティを [**なし**] に設定して、**レコードセット**を切断します。 詳細については、「 [データの更新と永続](./updating-and-persisting-data.md)化」の「レコードセットの切断と再接続」を参照してください。  
  
 データソースへの接続を閉じ、既存の **接続** オブジェクトを破棄します。 これにより、消費したリソースが解放されます。  
  
 最後に、フォーム上の Microsoft DataGrid コントロールのデータ**ソース**として**レコード**セットを設定します。これにより、フォームで**レコードセット**のデータを簡単に表示できるようになります。  
  
 2番目のボタン [ **データの確認**] をクリックします。 これにより、 **ExamineData** サブルーチンが実行されます。  
  
## <a name="examinedata"></a>ExamineData  
 ExamineData では、 **レコード** セットオブジェクトのさまざまなメソッドとプロパティを使用して、 **レコードセット**のデータに関する情報を表示します。 このメソッドは、 **RecordCount** プロパティを使用してレコードの数を報告します。 **レコードセット**をループ処理し、フォームの [表示] テキストボックスに**AbsolutePosition**プロパティの値を出力します。 さらに、ループ内では、3番目のレコードの **Bookmark** プロパティの値がバリアント変数 *vbookmark*に配置され、後で使用できるようになります。  
  
 ルーチンは、前の手順で格納したブックマーク変数を使用して、3番目のレコードに直接移動します。 ルーチンは、**レコードセット**の**フィールド**コレクションをループ処理し、コレクション内の各フィールドの詳細を表示する、 **"** **ウォークフィールド**" サブルーチンを呼び出します。  
  
 最後に、 **ExamineData**では、**レコードセット**の**Filter**プロパティを使用して、 **CategoryId**が2に等しいレコードのみを表示します。 このフィルターを適用した結果は、フォームの表示グリッドにすぐに表示されます。  
  
 **ExamineData**サブルーチンに示されている機能の詳細については、「[データの検査](./examining-data.md)」を参照してください。  
  
 次に、3番目のボタン [ **データの編集**] をクリックします。 これにより、 **Editdata** サブルーチンが実行されます。  
  
## <a name="editdata"></a>EditData  
 コードを **Editdata** サブルーチンに入力すると、 **レコードセット** は、フィルター条件に一致する項目だけが表示されるように、 **CategoryId** が2に等しいかどうかもフィルター処理されます。 最初に **レコードセット** をループ処理し、 **レコードセット** 内の各表示項目の価格を10% 増やします。 **Price**フィールドの値は、そのフィールドの [**値**] プロパティを新しい有効な金額に設定することによって変更されます。  
  
 **レコードセット**がデータソースから切断されていることに注意してください。 **Editdata**に加えられた変更は、ローカルにキャッシュされたデータのコピーに対してのみ行われます。 詳細については、「 [データの編集](./editing-data.md)」を参照してください。  
  
 4番目のボタン [ **データの更新**] をクリックするまで、データソースに対する変更は行われません。 これにより、 **UpdateData** サブルーチンが実行されます。  
  
## <a name="updatedata"></a>UpdateData  
 UpdateData 最初に、 **レコードセット**に適用されているフィルターを削除します。 このコードは、 `m_oRecordset1` フィルター処理されていない**レコードセット**がグリッドに表示されるように、フォームの Microsoft バインド DataGrid の**DataSource**として削除およびリセットします。  
  
 次に、**サポート**メソッドを**adMovePrevious**引数と共に使用して、**レコードセット**内を後方に移動できるかどうかを確認します。  
  
 このルーチンは、 **MoveFirst** メソッドを使用して最初のレコードに移動し、field オブジェクトの **Originalvalue** プロパティと **Value** プロパティを使用して、 **フィールドの** 元の値と現在の値を表示します。 これらのプロパティと **UnderlyingValue** プロパティ (ここでは使用しません) については、「 [データの更新と永続](./updating-and-persisting-data.md)化」で説明されています。  
  
 次に、新しい **接続** オブジェクトが作成され、データソースへの接続を再確立するために使用されます。 レコード**セットをデータソースに再**接続するには、新しい**接続**を**レコードセット**の**ActiveConnection**として設定します。 更新をサーバーに送信するために、コードは**レコードセット**で**UpdateBatch**を呼び出します。  
  
 バッチ更新が成功すると、モジュールレベルのフラグ変数 `m_flgPriceUpdated` が True に設定されます。 これにより、後でデータベースに加えられたすべての変更をクリーンアップするように通知されます。  
  
 最後に、コードは **レコードセット** 内の最初のレコードに戻り、元の値と現在の値が表示されます。 値は、 **UpdateBatch**を呼び出した後に同じです。  
  
 **レコードセット**が切断されている間にサーバー上のデータが変更された場合など、データを更新する方法の詳細については、「[データの更新と永続](./updating-and-persisting-data.md)化」を参照してください。  
  
## <a name="form_unload"></a>Form_Unload  
 **Form_Unload**サブルーチンは、いくつかの理由で重要です。 まず、これはサンプルアプリケーションであるため、Form_Unload は、アプリケーションが終了する前にデータベースに加えられた変更をクリーンアップします。 次に、このコードは、 **Execute**メソッドを使用して、開いている**接続**オブジェクトからコマンドを直接実行する方法を示しています。 最後に、行を返さないクエリ (UPDATE クエリ) をデータソースに対して実行する例を示します。